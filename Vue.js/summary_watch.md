# `watch`

## 概要

`watch` は、Vue.js において **リアクティブな値の「変化」を検知し、それを契機として副作用処理を実行するための仕組み** です。

`computed` が「値を導出するための仕組み」であるのに対し、`watch` は **「変化そのものをイベントとして扱う」** ために存在します。

API 呼び出し、ログ出力、外部状態との同期、DOM 依存処理など、
**値を返すことを目的としない処理** を安全に書くための手段です。

---

## この記事で伝えたいこと

- `watch` が **なぜ computed とは別に存在するのか**
- `watch` の基本構造と責務
- `deep` / `once` / `onWatcherCleanup()` / `flush` の意味と使い所
- `watch` を使いすぎないための判断軸

---

## 解決したい課題

Vue で開発していると、次のような要求が頻繁に発生します。

- 値が変わった「瞬間」に処理を実行したい
- オブジェクトの中身が変わったことを検知したい
- 非同期処理をキャンセル・クリーンアップしたい
- DOM 更新の前後、どのタイミングで処理を走らせるか制御したい
- 一度だけ反応すれば十分な処理を書きたい

これらはすべて、  
**「状態変化に反応した\*1 副作用制御」** という同一の課題に集約されます。

> \*1
> **副作用** とは、  
> **値を返すこと以外のことをする処理** を指します。

---

## 課題の原因

Vue の基本的なリアクティブ API には、次のような役割分担があります。

- `computed`
  → 値の派生（副作用なし）
- `methods`
  → 明示的に呼ばれる処理
- `watch`
  → 値の変化に反応する処理

しかし、`watch` を使わない場合、

- computed に副作用を書いてしまう
- methods を「いつ呼ばれるかわからない形」で使ってしまう
- 非同期処理の後始末ができない

といった **コードの責務が分かりにくくなる問題** が生じます。

---

## 課題を解決する技術、手法

### 技術、手法の概要

`watch` は、指定したリアクティブな値を監視し、その値が変化したときにコールバックを実行します。

```ts
watch(source, (newValue, oldValue) => {
  // 副作用処理
});
```

- `source`
  ref / computed / getter 関数
- `newValue`
  変更後の値
- `oldValue`
  変更前の値

さらに `watch` には、**「変化の捉え方」や「実行タイミング」** を制御するためのオプションが用意されています。

---

### 技術、手法の効果

`watch` を適切に使うことで、

- 副作用を computed から分離できる
- 非同期処理の競合を防げる
- DOM 更新タイミングを意識した処理が書ける
- 状態変化に対する責務が明確になる

結果として、
**「なぜこの処理がここにあるのか」が説明できるコード** になります。

---

### 課題がどう解決されるか

#### 基本例：値の変化に反応する

```ts
watch(searchKeyword, (value) => {
  fetchList(value);
});
```

- 値の変化だけを責務として持つ
- 値の派生や描画ロジックとは分離される

ここから、より高度な制御が必要になったときにオプションを使います。

---

### 応用事例

#### 1. `deep`：オブジェクト内部の変化を監視する

```ts
watch(
  formState,
  () => {
    validate();
  },
  { deep: true }
);
```

**用途**

- オブジェクト / 配列の「中身」が変わったことを検知したい

**注意点**

- 変更検知コストが高い
- 本当に必要な場合のみ使う

👉 _「ネストされた構造全体をイベントとして扱いたい」_ ときの選択肢

---

#### 2. `once`：最初の変化だけに反応する

```ts
watch(
  isReady,
  () => {
    initialize();
  },
  { once: true }
);
```

**用途**

- 初期状態 → 完了状態への遷移を一度だけ検知したい
- フラグの立ち上がりをトリガーにした初期化処理

👉 _「役目を終えたら自動で解除される watch」_

---

#### 3. `onWatcherCleanup()`：副作用の後始末を行う

```ts
watch(query, (value, _old, onCleanup) => {
  const controller = new AbortController();

  fetchData(value, controller.signal);

  onCleanup(() => {
    controller.abort();
  });
});
```

**用途**

- 非同期処理のキャンセル
- タイマー・イベントリスナーの解除

👉 _「前回の watch の副作用を安全に破棄する」ための仕組み_

---

#### 4. `flush`：実行タイミングを制御する

```ts
watch(
  state,
  () => {
    // DOM 参照処理
  },
  { flush: "post" }
);
```

| 値     | 実行タイミング           |
| ------ | ------------------------ |
| `pre`  | DOM 更新前（デフォルト） |
| `post` | DOM 更新後               |
| `sync` | 同期的に即実行           |

**用途**

- DOM サイズ計測 → `post`
- 状態同期のみ → `pre`
- 即時反応が必要 → `sync`

👉 _「いつ実行されるべきか」を明示できる_

---

#### 5. 複数値の監視

```ts
watch(
  () => [start.value, end.value],
  () => {
    updateSummary();
  }
);
```

- 関連する状態をひとまとまりのイベントとして扱う

---

## 留意点、デメリット

### watch は「最後の手段」ではないが「第一選択」でもない

- 値の派生 → `computed`
- 明示的な処理 → `methods`
- 状態変化に反応する副作用 → `watch`

この役割分担を崩すと、コードは一気に読みにくくなります。

---

### `deep` / `flush` / `cleanup` の乱用に注意

- **`deep` はコストが高い**  
  オブジェクト全体を再帰的に監視するため、  
  関係のないプロパティ変更でも watch が発火しやすく、  
  不要な再実行が増えてパフォーマンスが悪化する。

- **`flush: 'sync'` は設計を壊しやすい**  
  同期ウォッチャーはバッチ処理されず、  
  リアクティブな変更が検出されるたびに即座に実行される。  
  そのため、配列やオブジェクトなど  
  短時間に何度も更新されるデータと相性が悪く、  
  実行回数や順序が追いにくくなる。

- **cleanup が必要な watch は責務が重くなりやすい**  
  `onCleanup` を使用する場合、watch は  
  副作用の実行に加えて中断や破棄といった  
  ライフサイクル管理まで担うことになる。  
  その結果、watch が「変化検知」以上の役割を持っている  
  可能性を示すサインとして捉えられる。

👉 **「なぜこのオプションが必要なのか」を説明できるか** が判断基準

---
