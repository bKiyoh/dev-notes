# プリンシプル オブ プログラミング3年目までに身につけたい一生役立つ101の原理原則



## 🧠 第1章：前提 ～プログラミングの変わらぬ真実～

### 1.1 プログラミングに銀の弾丸はない

どんな技術や手法も「すべての問題を一発で解決」することはない。
言語やフレームワークを変えても、根本的な課題（設計・理解・運用）は残る。
→ 解決策を追うより、「問題を正しく見る力」を育てよう。

### 1.2 コードは設計書である

実際の設計は「コードの中」にある。
ドキュメントよりもコードを読めば、システムの思想や構造がわかる。
→ 書くときは「他人が読む設計書を書く」意識を持つ。

### 1.3 コードは必ず変更される

どんなコードも一度書いたら終わりではない。
仕様変更・環境変更・人の入れ替わりで、必ず修正される。
→ 「変更される前提」で設計することがプロの思考。

---



## ⚙️ 第2章：原則 ～プログラミングのガイドライン～

### **2.1 KISS ― Keep It Simple, Stupid（シンプルに保て）**

> 「賢く見せようとせず、シンプルに書け」

* 複雑な構造やトリッキーな書き方は、短期的にはカッコよく見えても、長期的にはメンテ不能になる。
* 「最も単純で、十分に動く方法」を選ぶ。
* シンプルさは“知的な怠惰”の結果であり、誰でも理解できるコードが最強。
  * 🧩 **例**：if文をネストせず早期returnにする、関数を短く保つ、条件を分かりやすく書く。

---

### **2.2 DRY ― Don’t Repeat Yourself（同じことを繰り返すな）**

> 「重複はバグの温床」

* 同じロジックを複数箇所に書くと、修正時にどこかを直し忘れる。
* 関数化・モジュール化・共通化で重複を排除する。
* ただし、「抽象化しすぎて複雑化する」のは本末転倒。
  🧩 **例**：同じバリデーションを各フォームで書くより、共通の関数にまとめる。

---

### **2.3 YAGNI ― You Aren’t Gonna Need It（きっとそれは要らない）**

> 「“将来必要になるかも”はやめよう」

* 未来のために書いたコードの9割は無駄になる。
* 今必要な機能だけを実装する。将来必要なら、そのとき作ればいい。
* 過剰な汎用化やオプション化は、理解を難しくし、保守コストを上げる。
  * 🧩 **例**：「多分使うかも」と思って作った設定項目が、結局誰も使わない。

---

### **2.4 PIE ― Prefer Interfaces over Inheritance（継承より委譲を）**

> 「継承よりもインターフェイスで柔軟に設計する」

* 継承は一見便利だが、親クラスの変更が子クラスすべてに影響する。
* 「共通化」ではなく「入れ替え可能性」を重視し、依存を減らす。
* コンポジション（委譲）で動きを組み合わせる方が拡張に強い。
  * 🧩 **例**：`Bird`クラスを`Flyable`インターフェイスに分け、鳥以外も飛べるようにする。

---

### **2.5 SLAP ― Single Level of Abstraction Principle（抽象レベルをそろえる）**

> 「1つの関数の中に、抽象のレベルを混ぜない」

* 関数の中に「全体の意図」と「細部の処理」が混在すると、読みにくい。
* 関数の中では、すべて同じ“高さ”の処理をそろえる。
* 上位レベルの意図（何をしたいか）と、下位レベルの手順（どうやるか）を分ける。
  * 🧩 **例**：「注文を処理する」関数の中に「合計金額を計算」や「税率を取得」を直接書かない。

---

### **2.6 OCP ― Open-Closed Principle（開放・閉鎖の原則）**

> 「拡張に開かれ、修正に閉じている設計を」

* 新しい機能を追加したいとき、既存コードを直さずに済む設計を目指す。
* インターフェイスや抽象クラスを使い、新機能を“差し込む”形にする。
* バグを生みにくく、チーム開発でも安全。
  * 🧩 **例**：通知の種類（メール／LINE／Slack）を増やす時、`Notifier`インターフェイスを継承するだけでOK。

---

### **2.7 名前重要（Name Matters）**

> 「よい名前はコメントを減らす」

* 名前はコードの“最初のドキュメント”。
* `x`や`data`よりも、目的を表す名前（`userEmail`、`calculateTaxRate`など）にする。
* 命名が正確なら、関数の中身を読まなくても意図が分かる。
* 悪い名前は誤解を招き、チーム全体の理解コストを上げる。
  * 🧩 **例**：「状態を返す関数」は `getStatus`、「値を変更する関数」は `updateStatus` と区別する。
 
いいですね！
では続いて、本書の**第3章「思想 ～プログラミングのイデオロギー～」**を詳しく解説します。
ここは全体の中でも“最も深い”章で、
「なぜシンプルさ・再利用性・分離が大事なのか」を理論面から掘り下げています。

---



## 🧠 第3章：思想 ～プログラミングのイデオロギー～

### **3.1 プログラミングセオリー**

> 「よいプログラムには共通の“理屈”がある」

プログラミングとは単に動かすだけでなく、**理解・拡張・再利用が容易であること**が大切。
そのための理論をまとめたのが「プログラミングセオリー」。
この後に出てくる価値・原則・思想はすべてその延長にある。

---

### **3.2 コミュニケーション（支える価値①）**

> 「コードは人と人をつなぐ言葉」

プログラマー同士は、コードを通じて会話している。
だから「分かりやすい」「一貫した」書き方が大切。
読む人がスムーズに理解できるコードは、それ自体がチームの生産性を上げる。

---

### **3.3 シンプル（支える価値②）**

> 「単純こそ最強の武器」

シンプルな構造は、バグを減らし、テストをしやすくし、変更も簡単。
複雑さはコードの敵であり、成長するほど「単純に保つ」力が問われる。

---

### **3.4 柔軟性（支える価値③）**

> 「変化に強い設計がよい設計」

技術も仕様もチームも常に変化する。
変化に耐えられるよう、コードの結合を弱くし、入れ替えやすくする。
“頑丈さ”より“しなやかさ”を目指す。

---

### **3.5 結果の局所化（実現する原則①）**

> 「変化の影響を小さく閉じ込める」

修正が必要なとき、できるだけ一か所の変更で済む構造にする。
影響範囲を限定すれば、リスクも少なくなる。
モジュール化・関数分割・依存の最小化はこのためにある。

---

### **3.6 繰り返しの最小化（実現する原則②）**

> 「同じことは一度だけ書く（DRYの発展形）」

同じコード・構造・概念の繰り返しを減らす。
重複をなくすことは、理解・変更・拡張を容易にする基本行為。
ただし、似ているだけのものを無理に共通化しないことも大切。

---

### **3.7 ロジックとデータの一体化（実現する原則③）**

> 「データを扱う処理は、データと一緒に置く」

データ構造と、それを操作する関数を近くに保つ。
「データはデータ層に、処理は別層に」ではなく、“意味的なまとまり”で結びつけると分かりやすい。

---

### **3.8 対称性（実現する原則④）**

> 「似たものは似たように書く」

対称性をそろえることで、予測可能で読みやすいコードになる。
片方にある処理がもう片方にもある、という規則性が大事。
（例：`open()` があれば `close()` がある、など）

---

### **3.9 宣言型の表現（実現する原則⑤）**

> 「“どう動くか”より“何をしたいか”で書く」

手続き的（命令的）に細かく書くより、「意図を表す」コードにする。
SQLやReactのJSXのように、“結果を宣言”する表現は保守がしやすい。

---

### **3.10 変更頻度（実現する原則⑥）**

> 「変わるものと変わらないものを分ける」

システムの中で“よく変わる部分”と“ほとんど変わらない部分”を明確に分離する。
変更しやすい部分を外に出し、安定部分は内側に閉じ込めることで、設計が安定する。

---

### **3.11 アーキテクチャ根底技法**

> 「大きなシステムを支える基本構造の考え方」

ここから先は、ソフトウェア設計全体に通じる基礎技法が並ぶ。
抽象化・カプセル化・情報隠蔽など、設計者の“道具箱”となる要素。

---

### **3.12 抽象（技法①）**

> 「具体から共通点を抜き出す」

複数の具体例から本質を取り出し、再利用できる形にする。
抽象が高すぎると使いにくいが、適度な抽象化は変更への耐性を生む。

---

### **3.13 カプセル化（技法②）**

> 「外から中を直接触らせない」

内部の仕組みを隠し、必要な操作だけ公開する。
これにより安全に変更でき、外部との影響を減らせる。

---

### **3.14 情報隠蔽（技法③）**

> 「知る必要のないことは隠す」

利用者は内部構造を知らなくていい。
“見せない”ことは“守る”こと。
モジュールの独立性を高め、チーム開発でも干渉を減らす。

---

### **3.15 パッケージ化（技法④）**

> 「関連する要素をまとめてグループ化」

機能単位・責務単位でファイルやクラスをまとめる。
ディレクトリ構造も“理解の構造”である。
モジュール境界を明確にすると再利用性が上がる。

---

### **3.16 関心の分離（技法⑤）**

> 「目的ごとに責任を分ける」

UI・データ・ビジネスロジックなど、役割ごとに分ける。
MVCやクリーンアーキテクチャもこの思想に基づく。
分離が不十分だと、1つの変更が全体を壊す。

---

### **3.17 充足性・完全性・プリミティブ性（技法⑥）**

> 「構造は“ちょうどよく”」

* **充足性**：必要なものがすべて含まれている
* **完全性**：不要なものが含まれていない
* **プリミティブ性**：これ以上分けられない最小単位
  この3つのバランスで、よいモジュールができる。

---

### **3.18 ポリシーと実装の分離（技法⑦）**

> 「“何をするか”と“どうやるか”を分ける」

たとえば「認証を行う」という方針（ポリシー）と、
「OAuthを使う」という実装は別物。
この2つを切り離すことで、仕組みを変えてもポリシーは守れる。

---

### **3.19 インタフェースと実装の分離（技法⑧）**

> 「外から見える契約と中の実装を分ける」

インタフェース（契約）を固定し、内部の仕組みは自由に変えられるようにする。
これによりリファクタリングが容易になる。

---

### **3.20 参照の一点性（技法⑨）**

> 「同じ情報を複数の場所で持たない」

同じデータを複数の場所で管理すると矛盾やバグが起きる。
「唯一の情報源（Single Source of Truth）」を守ることで整合性を保つ。

---

### **3.21 分割統治（技法⑩）**

> 「大きな問題は小さく分けて解く」

複雑な問題を分割し、個々を独立して解決する。
それぞれが独立して動く構造を作ることで、開発もテストも簡単になる。

---

### **3.22 アーキテクチャ非機能要件**

> 「設計の“性能以外”の重要な指標」

機能だけでなく、「変更しやすいか」「安全か」「再利用できるか」なども設計の品質を決める。

---

### **3.23～3.28 各非機能要件**

| 要件     | 内容            |
| ------ | ------------- |
| 変更容易性  | 修正しやすい構造にする   |
| 相互運用性  | 他のシステムと連携しやすい |
| 効率性    | 無駄のないリソース使用   |
| 信頼性    | 予測どおり動作し続ける   |
| テスト容易性 | 自動テストしやすい設計に  |
| 再利用性   | 他の場面でも使い回せる   |

---

### **3.29〜3.36 7つの設計原理**

| 原理   | 概要              |
| ---- | --------------- |
| 単純原理 | シンプルさを最優先せよ     |
| 同型原理 | 同じ構造は同じ形で書く     |
| 対称原理 | 似たものは対応させる      |
| 階層原理 | 層構造で理解を助ける      |
| 線形原理 | 流れを直線的に、分岐を最小に  |
| 明証原理 | 意図が明確であること      |
| 安全原理 | エラーに強く、安全に壊れる構造 |

---

### **3.37〜3.54 UNIX思想（17原則）**

> UNIX文化の中で育った「シンプルで強い設計の哲学」。

代表的なもの：

* **モジュール化**：小さな部品に分ける
* **明確性**：曖昧さを避ける
* **組み立て部品**：小さなツールを組み合わせて大きな力に
* **単純性と倹約**：最小限で最大の効果
* **透明性と安定性**：挙動を予測できる
* **拡張性**：後からでも成長できる

---

### **3.55〜3.64 UNIX哲学（9原則）**

> UNIXの設計哲学をさらに簡潔にしたもの。

1. 小は美なり
2. 1つのプログラムは1つの仕事を
3. すぐ動くプロトタイプを作る
4. 効率より移植性
5. データはテキストで扱う
6. 他のソフトをうまく使え
7. シェルで組み合わせよ
8. 対話的操作を避けよ
9. フィルタ化して再利用せよ

---



## 👁 第4章：視点 ～プログラマの観る角度～

### **4.1 凝集度（Cohesion）**

> 「ひとまとまりの中の要素が、どれだけ同じ目的を持っているか」

* 凝集度が高い＝1つのモジュールが、1つの責務をしっかり持っている。
* 凝集度が低い＝バラバラな目的の処理が混ざっている。
* クラスや関数の内部で「何をしたいか」が明確に一貫しているほど良い。

🧩 **例**：
✔️ `UserService` → ユーザー情報の登録・認証・更新だけを担当。
❌ `UserService` がログ出力や画面更新までしている。

---

### **4.2 結合度（Coupling）**

> 「他のモジュールとの“つながりの強さ”」

* 結合度が高い＝他の部分に強く依存している（壊れやすい）。
* 結合度が低い＝独立しており、他の変更の影響を受けにくい。
* よい設計は「凝集度が高く、結合度が低い」状態を目指す。

🧩 **例**：
✔️ 外部ライブラリを直接呼ばず、ラッパー関数を通すことで依存を減らす。
❌ コンポーネント同士が相互に import している。

---

### **4.3 直交性（Orthogonality）**

> 「機能が独立していて、他を壊さずに変更できること」

* ある部分の変更が、他の部分に影響しない状態。
* 直交性が高いほど、バグを生みにくく、テストが容易になる。
* “交わらない”という意味から、機能の分離を徹底する思想。

🧩 **例**：UIの変更がビジネスロジックに影響しない構成。

---

### **4.4 可逆性（Reversibility）**

> 「決定を後からでも変えられる柔軟さ」

* “間違っても戻せる設計”が強い。
* 技術選択や実装方針をすぐに変えられるよう、依存を弱くする。
* 設計初期にすべてを固定しすぎないこと。

🧩 **例**：
データベースを直接操作せず、リポジトリ層を挟めば、DBを後で差し替えられる。

---

### **4.5 コードの臭い（Code Smells）**

> 「一見動いているけど、“何かがおかしい”サイン」

* 臭い（smell）は、バグではないが将来問題を起こす“予兆”。
* 代表的な臭い：

  * 関数が長すぎる
  * 条件分岐が複雑
  * 変数名が抽象的すぎる
  * クラスが多機能すぎる（God Class）
* 臭いを感じたらリファクタリングのサイン。

🧩 **例**：`Manager`や`Utils`などの曖昧な名前は臭いの典型。

---

### **4.6 技術的負債（Technical Debt）**

> 「“後回しにした問題”は、後で利息付きで返すことになる」

* 期限優先で雑に作ると、後で修正に時間とコストがかかる。
* すぐに問題が起きなくても、累積して大事故になる。
* “リファクタリング”“コードレビュー”“自動テスト”で利息を小さくするのが重要。

🧩 **例**：
✔️ 「とりあえず動くからOK」を繰り返した結果、1年後に誰も触れないコードになる。
❌ リリース直前に“仮実装”を放置して本番投入。

---



## 🌿 第5章：習慣 ～プログラマのルーティーン～

### **5.1 プログラマの3大美徳（The Three Virtues）**

> ラリー・ウォール（Perlの生みの親）の有名な言葉。

1. **怠惰（Laziness）**
   → 面倒を避けるために自動化・効率化する。
   “怠惰”は、繰り返しを減らすエンジニアの知恵。

2. **短気（Impatience）**
   → 待たされるのが嫌だから、レスポンスの速い仕組みを作る。
   “短気”は、ユーザー体験を良くする推進力。

3. **傲慢（Hubris）**
   → 自分の書いたコードに誇りを持ち、他人に恥ずかしくないよう仕上げる。
   “傲慢”は、品質意識の根源。

🧩 **まとめ**：怠惰・短気・傲慢は悪徳ではなく、**良い開発を促す感情のエネルギー**。

---

### **5.2 ボーイスカウトの規則（Boy Scout Rule）**

> 「キャンプ場を来たときよりきれいにして帰る」

コードベースも同じ。
触った場所を少しでも良くしてからコミットする。
リファクタリングや命名の改善、小さな整理を怠らない。

🧩 **例**：
バグを修正するついでに変数名をわかりやすくする、コメントを補足する、など。
毎日少しの清掃で、コードの健康が保たれる。

---

### **5.3 パフォーマンスチューニングの箴言**

> 「まず正しく動かせ。次に速くせよ」

* 早さを追う前に、正しさを確保する。
* 測定せずに最適化するのは時間の無駄。
* 真のボトルネックは、勘ではなく計測で見つける。

🧩 **鉄則**：**「動く → 測る → 改善する」**の順を守る。

---

### **5.4 エゴレスプログラミング（Egoless Programming）**

> 「自分のコードにプライドは持っても、執着は持つな」

* コードレビューで批判されても、人格を否定されたわけではない。
* チーム全員で良いコードを育てる姿勢を持つ。
* “自分の書いたコード＝チームの資産”と考える。

🧩 **心得**：
レビューコメントに感情で反応せず、「なぜそう指摘されたのか」を考える。

---

### **5.5 一歩ずつ少しずつ（Small Steps）**

> 「大きな変更を一度にやろうとするな」

* 小さく区切って進めると、エラー箇所が特定しやすく、チームレビューもしやすい。
* 1つのPR（Pull Request）は“小さく完結”。
* 成功体験を積み上げると、モチベーションも持続する。

🧩 **例**：
Vue2→Vue3移行のような大規模改修も、「一画面ずつ」「一モジュールずつ」着実に。

---

### **5.6 TMTOWTDI（There’s More Than One Way To Do It）**

> 「やり方はひとつじゃない」

* どんな課題にも複数の解法がある。
* “他人のやり方”も尊重し、柔軟に取り入れること。
* ただし、プロジェクト全体では「一貫性」を優先する。

🧩 **教訓**：
多様性を認めつつ、チームではガイドラインを持つ。
“統一された自由”が理想。

---
